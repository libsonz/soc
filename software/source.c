#include <stdio.h>
#include "system.h" // Generated by BSP, defines base addresses
#include "altera_avalon_pio_regs.h" // Useful if using PIOs for control/status
#include "sys/alt_stdio.h"

// Include the header file for your custom component (replace with actual name)
// This file is generated by the BSP based on your Platform Designer system
#include "your_matrix_multiplier_inst.h"

// Define base address and register offsets (adjust based on your BSP header)
// The BSP header will define YOUR_MATRIX_MULTIPLIER_INST_BASE
#define MM_CONTROL_REG    YOUR_MATRIX_MULTIPLIER_INST_BASE + 0
#define MM_STATUS_REG     YOUR_MATRIX_MULTIPLIER_INST_BASE + 1
#define MM_CREAD_ADDR_REG YOUR_MATRIX_MULTIPLIER_INST_BASE + 2
#define MM_CREAD_DATA_REG YOUR_MATRIX_MULTIPLIER_INST_BASE + 3

// Define bit masks for control/status bits (adjust based on your wrapper)
#define MM_CONTROL_START_MASK (1 << 0)
#define MM_CONTROL_RESET_MASK (1 << 1) // If you implemented synchronous reset
#define MM_STATUS_DONE_MASK   (1 << 0)
#define MM_STATUS_BUFFER_VALID_MASK (1 << 1)

int main() {
    alt_putstr("Nios II Starting Matrix Multiplication...\n");

    // --- Example: Loading Matrix A and B (Conceptual - requires wrapper support) ---
    // If you implemented loading via Avalon MM:
    // alt_putstr("Loading matrices A and B...\n");
    // for (int i = 0; i < M; i++) {
    //     for (int k = 0; k < K; k++) {
    //         // Write A[i][k] to the appropriate address/register
    //         // IORD_32(MM_A_LOAD_DATA_REG, 0); // Example using IORD/IOWR macros
    //         // IOWR_32(MM_A_LOAD_ADDR_REG, address_for_A_ik);
    //         // IOWR_32(MM_A_LOAD_DATA_REG, matrix_A[i][k]);
    //     }
    // }
    // // Similar loop for Matrix B
    // alt_putstr("Matrix loading complete.\n");


    // --- Initiate Matrix Multiplication ---
    alt_putstr("Initiating matrix multiplication...\n");
    // Write to the control register to assert the start_mult bit
    IOWR_8(MM_CONTROL_REG, MM_CONTROL_START_MASK); // Use IOWR_8, _16, or _32 based on register width

    // --- Wait for Multiplication to Complete ---
    alt_putstr("Waiting for multiplication to finish...\n");
    unsigned int status;
    do {
        // Read the status register
        status = IORD_8(MM_STATUS_REG); // Use IORD_8, _16, or _32 based on register width
    } while (!(status & MM_STATUS_DONE_MASK)); // Loop until mult_done bit is high

    alt_putstr("Matrix multiplication finished.\n");

    // --- Example: Reading Result from C BRAM ---
    alt_putstr("Reading result matrix C...\n");
    unsigned int c_element;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            // Write the address of C[i][j] to the C read address register
            unsigned int c_address = i * N + j; // Flattened address
            IOWR_8(MM_CREAD_ADDR_REG, c_address); // Write address

            // Wait for the data to be available (if your C BRAM has read latency)
            // If C BRAM read is synchronous 1-cycle, data is ready next cycle.
            // You might need a small delay or check a data_valid signal if implemented.
            // For simplicity, assuming data is available after writing address:

            // Read the data from the C read data register
            c_element = IORD_32(MM_CREAD_DATA_REG); // Use IORD_32 if ACC_WIDTH_PE is 32 bits or less

            printf("C[%d][%d] = %x\n", i, j, c_element);
        }
    }

    alt_putstr("Result reading complete.\n");

    return 0;
}
